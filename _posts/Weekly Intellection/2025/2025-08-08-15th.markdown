---
layout:     post
title:      "2025-每周补脑15th"
subtitle:   ""
date:       2025-08-08 22:36:00
author:     "XiLock"
header-img: "img/in-post/2018/wl-bg.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 每周补脑
    - 2025


---

### 科学


### 言论
1. 2023年我回到美国，在耶鲁法学院待了一段日子。那里是精英法学院，是雄心勃勃、想要跻身美国政府高层的人的捷径。这段日子让我强烈感受到，美国是一个律师社会。律师在美国社会占主导地位，这促使美国沦为一个诉讼至上的否决制国家。无论你想做什么事，反对者都会试图通过律师来否决你。我相信，如果美国如此执着于一个主要为富人和权贵阶层服务的体系，它就不可能继续保持强国地位。我逐渐形成了这样的观点：中国是一个工程国家，它用大型工程（包括社会工程）来解决物质和社会问题，而美国则是一个律师社会，它用法律阻止几乎所有的事情，无论好坏。除此之外，美国人和中国人从根本上来说很相似：永不停歇，渴望走捷径，最终推动着世界上大多数重大变革。 -- Dan Wang《Breakneck: China's Quest to Engineer the Future》
1. 我这辈子认识的聪明人，没有一个是不大量读书的，一个也没有。巴菲特的阅读量之大，会让你大吃一惊。我的孩子们甚至嘲笑我，是一本伸出几条腿的书。 -- [Charlie Munger(Rao Reading Algorithm)](https://raohacker.com/rao-reading-algorithm/)
1. AI 不会减少你掌握新技能所需要付出的努力，只会让你产生不必学习就已经学会的错觉。 -- [AI Doesn't Lighten the Burden of Mastery](https://playtechnique.io/blog/ai-doesnt-lighten-the-burden-of-mastery.html)
1. 函数的参数个数，可以看成空间的维度，2个参数就是二维空间，2500个参数就是2500维的空间。猫照片的函数就是在2500维空间里面，通过大量训练，找到一条分界线，从而算出任意一张照片落在线内的概率有多大。 -- [How Can AI ID a Cat? An Illustrated Guide](https://www.quantamagazine.org/how-can-ai-id-a-cat-an-illustrated-guide-20250430/)
1. Consistent reliance on AI tools might undermine learning, memory, and creativity. Discomfort isn’t just a nuisance – it’s a training ground. Look for discomfort, seek it out, and encourage it.  -- [In the long run, LLMs make us dumber](https://desunit.com/blog/in-the-long-run-llms-make-us-dumber/)
1. 大模型是压缩信息的一种方式，即使不精确、有幻觉和遗漏，也比什么都没有要好。大模型已经是一个可用的、公开的、有损的互联网压缩视图。 -- [Big LLMs weights are a piece of history](https://antirez.com/news/147)


### 观点
###### 君子可欺以其方（《孟子·万章上》）
万章说：“父母叫舜修理粮仓，（等他爬上仓后，）拿掉了梯子，（他父亲）瞽瞍放火烧粮仓，（想把舜烧死。）又曾叫舜淘井，（舜已经逃）出了井，（瞽瞍不知道，）随即就填井，（想把舜埋在井里。）象说：‘谋害舜都是我的功劳。（害死了他，他的）牛羊归父母，粮食归父母，干戈归我，琴归我，弓归我，让两个嫂嫂替我整理床铺。’象走进舜的住房，（不料舜没有死，）舜正在床上弹琴。象（赶忙掩饰）说：‘我可想念你啦！’神情很不自然。舜说：‘我惦念着这些臣仆，希望你来帮我管理。’我不知道，**舜真的不晓得象要杀害他吗？”孟子说：“怎么会不知道呢？**（舜看重兄弟情义，）象忧愁，他也忧愁；象高兴，他也高兴。”万章说：“这么说，舜是假装高兴的吗？”孟子说：“不。从前有人送条活鱼给郑国的子产，子产叫管理池塘的小吏把它放养到池塘里。小吏把鱼煮煮吃了。回来报告说：‘刚放它时，半死不活的；不一会儿就摇摆着尾巴游开了；一转眼就游不见了。’子产说：‘得着它的好去处了！得着它的好去处了！’小吏出来后说：“谁说子产聪明？我都把鱼煮吃掉了，他还说：得着它的好去处了，得着它的好去处了。’所以君子可以用合乎道理的事欺骗他，难以用没有道理的事蒙骗他。象装着敬爱兄长的样子来了，所以**舜真诚地相信他，而且感到高兴，怎么是假装的呢？**”

###### [My Engineering Craft Regressed](https://lemmy.ml/post/30100312)
五年前，我大学毕业时，很热衷于软件开发，参与了一大堆开源项目。

我全身心投入，为这些项目投入了数千小时。虽然没有回报，但我非常享受这些时间，项目用户也对我的工作评价很高。

毕业后，我开始找工作。我认为，公司会看重我的开源经历。我想错了。

我申请了600多个职位，告诉公司我为开源项目做了许多贡献，但结果只收到了3个 offer。最终，我接受了一家创业公司的 offer。

白天，我为这家创业公司工作八九个小时。回到家后，我继续投入自己的开源项目，直到深夜。

我的薪水少得可怜，但是我乐在其中。我的技能快速提高，社区影响力也显著提升。

终于有一天，我认清了现实。公司的项目根本不能体现我的价值，知道我价值的人，又不是能付钱给我的人。我退缩了，开始苦练 Leetcode。

我不再在开源项目投入很多时间，项目社区也渐渐失去了活力。放弃开源项目让我很难过，但我因此进入了一家大公司，我的薪水增加了5倍。

我把所有时间投入了公司的项目，得到了领导的好评。我的邮箱开始塞满了各种挖我跳槽的邮件。

但是，我知道，自己的技术退步了。公司的项目很枯燥，没有挑战性，使用的是内部技术栈。

此外，我也远不如以前快乐。

我想我会攒点钱，过几年就退休，希望那时开源世界还像以前一样。

###### [GitHub 的高级工程师sean goedecke:Everything I know about good system design](https://www.seangoedecke.com/good-system-design/)
1. 程序设计是组装代码，系统设计是组装服务。程序设计的组件是变量、函数、类等，系统设计的组件是服务器、数据库、缓存、队列、事件总线、代理等。 
1. 如果一个系统很长时间不出错，它的设计就是良好的。如果你进一步看了代码，脱口而出："哈，这比我想的要简单"，或者"这个部分不用我操心，即使出问题也容易解决"，它的设计就是优秀的。 
1. 良好的系统设计，总是从一个有效的简单系统发展而来。千万不要从零开始设计一个复杂的系统。
1. 系统设计的难点在于状态。尽量采用无状态组件，最小化"有状态组件"的数量。状态的复杂性在于，你无法简单地重启服务。一旦出错，往往需要手动修复状态。
1. 状态需要保存在数据库。数据库是最重要的系统组件，用来管理状态。数据库的设计目标是每张表易于理解：打开看一下表结构，就能大致了解存储的数据内容及其原因。千万不要采用复杂的表结构（也就是数据结构），会给代码带来极大的复杂性和性能约束。
1. 数据库往往是系统瓶颈，因为每个页面请求可能要调用数十次、数百次数据库，而且是按顺序调用。为了避免瓶颈，数据库可以做成一个写入节点和多个只读副本。数据查询都发往只读副本，数据写入发往写入节点。写入节点与只读副本之间，存在数据复制延迟。如果更新一条记录后，你需要立即读取它，那么可以将数据放入内存，写入数据库成功后从内存读取。
1. 耗时的操作要拆分出来，放在后台作业（即系统外部的单独服务），排队完成。后台作业主要分成两个组件：一个队列服务，一个作业运行器（从队列中获取任务并执行）。队列任务的软件，可以用 Redis（需要尽快执行的任务），也可以用数据库（不着急的任务）。
1. 如果数据的生成速度和读取速度不匹配，经典解决方案就是缓存。缓存的最简单做法，就是把数据保存在内存，否则就使用专门的键值存储软件（比如 Redis 或 Memcached），后者的好处是多个服务器可以共享缓存。初级工程师希望缓存所有内容，而高级工程师希望尽量少用缓存。因为缓存是状态的来源，不可避免需要校验状态和处理状态过期。
1. 除了缓存和后台作业，大型系统通常还有事件中心，一般用的是 Kafka。事件中心也是一个队列，存放的是"某件事发生了"的消息。比如，用户注册触发了"新帐户创建"事件，该事件就放入事件中心，然后由事件中心去通知订阅该事件的多个服务：发送欢迎电子邮件、设置个人空间等等。事件中心适用于，发送事件的代码不关心其他服务如何处理事件，或者事件量很大且对响应时间不太敏感。不要过度使用事件，很多时候，更简单的做法是让一个服务请求另一个服务的 API。为了便于除错，所有日志最好都放在一起，你可以立即看到另一个服务的响应。
1. 如果数据需要传送到多处，有拉取（pull）和推送（push）两种选择。一般来说，拉取比较简单（比如大多数网站采用的轮询），推送更节省资源，不需要用户主动请求数据，一旦后端数据发生变化，服务器主动将数据推送给每个客户端。如果你确实需要向100万个客户端提供最新数据（就像 GMail 那样），应该采用推送还是拉取？这要视情况而定。如果采用推送，就要把每次推送放入一个事件队列，并让一大群事件处理器从队列中拉取数据并推送。如果采用拉取，就要部署一堆（比如100台）快速的只读缓存服务器，处理所有读取流量。


### 有趣


### 荐书


### 杂谈


![](/img/wc-tail.GIF)
